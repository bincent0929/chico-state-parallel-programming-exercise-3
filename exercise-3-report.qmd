---
title: "exercise-3-report"
format:
  pdf:
    code-overflow: wrap
    include-in-header:
      text: |
        \usepackage{fvextra}
        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,breakanywhere,commandchars=\\\{\}}
        \DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,breakanywhere,commandchars=\\\{\}}
---

::: {.callout-important}
Change directory into `MPI_Examples/` and then `hello_integrators/` and run `make` to compile
the code into programs.
:::

## 1.

### a).

For testing the Riemann sum sequentially (using the left sum), I compiled and ran `hello_riemann.cpp` in integrating a constant function $f(x) = 10.0$ over the interval $0$ to $10.0$ using a step size of $1000000$ at a precision of $15$.

This was the result:
```bash
$ ./hello_riemann 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 10.000000000000000 with 1000000 steps is 100.000000000000014
```

For testing the Trapezoidal sum sequentially, I compiled and ran `hello_trapezoidal_constant.cpp`. I used the same values as above with the Riemann sum, and this, as you may expect, was the output:
```bash
$ ./hello_trapezoidal_constant 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 10.000000000000000 with 1000000 steps is 100.000000000000014
```

### b).

Here's the result of $f(x)=sin(x)$ using the trapezoidal method at 15 point precision:
```bash
$ ./hello_riemann 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 3.141592653589793 with 1000000 steps is 1.999999999998408
```

And here's for the Riemann sum (using the left):
```bash
$ ./hello_trapezoidal
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 3.141592653589793 with 1000000 steps is 1.999999999998408
```

### c).

Both methods produced the same results in testing the constant function and the sine function at 15 point precision. This is curious, and I'm assuming it's due to compiler optimizations because, in theory, the trapezoidal method should result in a more precise numerical value than the left Riemann sum.

Knowing this fact, I just I went ahead and picked the trapezoidal method.

Check out `MPI_Examples/simple_function_mpi_trap.c` and see my code.

The output for it is with one process:
```bash
$ time mpiexec -n 1 ./simple_function_mpi_trap
With n = 100 trapezoids, our estimate
of the integral from 0.000000 to 100000.000000 = 1.000000000000000e+06

real    0m0.288s
user    0m0.023s
sys     0m0.038s
```

The output for it with multiple processes:
```bash
$ time mpiexec -n 5 ./simple_function_mpi_trap
With n = 100 trapezoids, our estimate
of the integral from 0.000000 to 100000.000000 = 1.000000000000000e+06

real    0m0.296s
user    0m0.052s
sys     0m0.080s
```

::: {.callout-note}
- I have 8 cores to be able to work on this, but due to the way this is set up, using 5 cores correctly divides the wxork across the cores to not cause remainder issues which results in incorrect calculations. 

- It also isn't much faster because the amount of work isn't large enough to see a significant speed up with extra processes.
:::

## 2.

::: {.callout-caution}
The rest of my solutions will be available in `train_problems_solutions.c`

- Make sure to set the definitions at the top of the file to the desired outputs for the program:
    - For Part 2:
      - Set to PART2 + VELOCITY || DISPLACEMENT
    - For Part 3:
      - Set to PART3 + VELOCITY || DISPLACEMENT
    - For Part 4:
      - Set to PART4 + VELOCITY || DISPLACEMENT
    - (HALF_TIME is used to check whether the derivation of velocity from acceleration actually produces the correct value by getting the peak value).

Run the program using `time mpiexec -n 1 ./train_problem_solutions` for a single process result and `time mpiexec -n 8 ./train_problem_solutions` (which seems to not have remainder issues in my testing) to get similar multi-process results.
:::

### Left Riemann -  Step Size .00001 - Float Numerical Values

I had to make the step size smaller to produce a noticeable difference between the single process vs. multi-process.

#### Velocity

For the velocity in the case where the step size is .00001, make sure to set your definitions to set to PART2 + VELOCITY.

This was the output that I got when using one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000000, step_size=0.000010
After LeftRiemann: my_rank=0, integrated area =      32.0000000, step_size 0.000010, number quadratures=180000000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =      32.0000000

real    0m1.109s
user    0m0.854s
sys     0m0.028s
```

The result is eery far off from the 0.0. that we're expecting here. It seems that the error coming from using float values and the left Riemann method of summation is procuding very significant error.

This was the output I got when using multiple processes:
```bash
time mpiexec -n 8 ./train_problem_solutions
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500000, step_size=0.000010
After LeftRiemann: my_rank=0, integrated area =      20.0888042, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=5, integrated area =     -32.0000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=3, integrated area =      32.0000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=1, integrated area =      32.0000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=7, integrated area =     -32.0000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=2, integrated area =      57.0229530, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=4, integrated area =       0.0000076, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=6, integrated area =     -57.0229530, step_size 0.000010, number quadratures=22500000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =      20.0888119

real    0m0.489s
user    0m1.323s
sys     0m0.210s
```

This is better, but still very significantly far off.

#### Displacement

Make sure to set your definitions to PART2 + DISPLACEMENT.

Here it is for one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000000, step_size=0.000010
After LeftRiemann: my_rank=0, integrated area =    8192.0000000, step_size 0.000010, number quadratures=180000000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =    8192.0000000

real    0m2.025s
user    0m1.770s
sys     0m0.028s
```

This is hilariously far off from our expected 122 km. Like, A LOT.

Here it is for multiple processes:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500000, step_size=0.000010
After LeftRiemann: my_rank=2, integrated area =   16384.0000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=0, integrated area =    1600.5000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=3, integrated area =   28931.1484375, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=7, integrated area =    4096.0000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=1, integrated area =    6818.4086914, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=6, integrated area =   16384.0000000, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=5, integrated area =   28931.1484375, step_size 0.000010, number quadratures=22500000
After LeftRiemann: my_rank=4, integrated area =   32768.0000000, step_size 0.000010, number quadratures=22500000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =  135913.2031250

real    0m0.680s
user    0m2.659s
sys     0m0.355s
```

This is certainly better. But still very far off.

## 3.

### Midpoint - Step Size .00001 - Double Numerical Values

#### Velocity

Here's the output for one process:
```bash
ime mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000000, step_size=0.000010
After MidpointRiemann: my_rank=0, integrated area =   -0.000000071792305, step_size 0.000010, number quadratures=180000000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =   -0.000000071792305

real    0m2.102s
user    0m1.844s
sys     0m0.029s
```

This is definitely MUCH better than the results from part 2.

I also wanted to do a half-time check to get the peak value to make sure it's correct.

So the right endpoint is 900:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000000, step_size=0.000010
After MidpointRiemann: my_rank=0, integrated area =   -0.000000071792305, step_size 0.000010, number quadratures=180000000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =   -0.000000071792305

real    0m2.101s
user    0m1.842s
sys     0m0.027s
```

And according to our values in the spreadsheet, this is pretty close to correct!

And here are those using more processes:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500000, step_size=0.000010
After MidpointRiemann: my_rank=0, integrated area =   19.851651501278297, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=2, integrated area =   47.926126306384660, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=3, integrated area =   19.851651547480213, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=5, integrated area =  -47.926126267031840, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=1, integrated area =   47.926126272365089, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=6, integrated area =  -47.926126306384674, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=4, integrated area =  -19.851651452443065, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=7, integrated area =  -19.851651547480149, step_size 0.000010, number quadratures=22500000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =    0.000000054168531

real    0m0.710s
user    0m2.788s
sys     0m0.483s
```

```bash

(.venv) vscode âžœ /workspaces/chico-state-parallel-programming-exercise-3/MPI_Examples (main) $ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=900.00000000000000, number of total steps=90000000
my_rank=0, start a=0.000000, end b=112.500000, number of quadratures = 11250000, step_size=0.000010
my_rank=6, start a=675.000000, end b=787.500000, number of quadratures = 11250000, step_size=0.000010
my_rank=7, start a=787.500000, end b=900.000000, number of quadratures = 11250000, step_size=0.000010
my_rank=2, start a=225.000000, end b=337.500000, number of quadratures = 11250000, step_size=0.000010
my_rank=4, start a=450.000000, end b=562.500000, number of quadratures = 11250000, step_size=0.000010
my_rank=1, start a=112.500000, end b=225.000000, number of quadratures = 11250000, step_size=0.000010
my_rank=3, start a=337.500000, end b=450.000000, number of quadratures = 11250000, step_size=0.000010
my_rank=5, start a=562.500000, end b=675.000000, number of quadratures = 11250000, step_size=0.000010
After MidpointRiemann: my_rank=0, integrated area =    5.159276130521250, step_size 0.000010, number quadratures=11250000
After MidpointRiemann: my_rank=1, integrated area =   14.692375368876426, step_size 0.000010, number quadratures=11250000
After MidpointRiemann: my_rank=2, integrated area =   21.988693639526645, step_size 0.000010, number quadratures=11250000
After MidpointRiemann: my_rank=3, integrated area =   25.937432636366228, step_size 0.000010, number quadratures=11250000
After MidpointRiemann: my_rank=5, integrated area =   21.988693650344832, step_size 0.000010, number quadratures=11250000
After MidpointRiemann: my_rank=4, integrated area =   25.937432641478278, step_size 0.000010, number quadratures=11250000
After MidpointRiemann: my_rank=7, integrated area =    5.159276142816300, step_size 0.000010, number quadratures=11250000
After MidpointRiemann: my_rank=6, integrated area =   14.692375378943535, step_size 0.000010, number quadratures=11250000
After Reduce: with n = 90000000 quadratures, our estimate
of the integral from 0.000000 to 900.000000 =  135.555555588873517

real    0m0.505s
user    0m1.450s
sys     0m0.309s
```

These are also much closer than the results from part 2 to 0.0.

#### Displacement

Here's the output from one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000000, step_size=0.000010
After MidpointRiemann: my_rank=0, integrated area = 122000.000301758234855, step_size 0.000010, number quadratures=180000000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000301758234855

real    0m2.185s
user    0m1.932s
sys     0m0.026s
```

This is WAY better than what we got from part 2. The use of double and the midpoint method (probably more-so the use of doubles) makes this a much better result.

Here's the output from multiple processes:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500000, step_size=0.000010
After MidpointRiemann: my_rank=2, integrated area = 20937.079222946016671, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=6, integrated area = 9562.920777051402183, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=5, integrated area = 20937.079250167345890, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=4, integrated area = 28979.823828839602356, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=0, integrated area = 1520.176179318903451, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=1, integrated area = 9562.920753811566101, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=3, integrated area = 28979.823817559143208, step_size 0.000010, number quadratures=22500000
After MidpointRiemann: my_rank=7, integrated area = 1520.176182441816309, step_size 0.000010, number quadratures=22500000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000012135802535

real    0m0.681s
user    0m2.625s
sys     0m0.229s
```

Even closer to what we're expecting!

## 4.

### Trapezoidal Method - 1ms Step Size - Double Numerical Values

#### Velocity

Here it is for one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000000, step_size=0.000010
After Trap: my_rank=0, integrated area =    0.000000000000003, step_size 0.000010, number quadratures=180000000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =    0.000000000000003

real    0m2.076s
user    0m1.825s
sys     0m0.025s
```

And for multiple:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500000, step_size=0.000010
After Trap: my_rank=2, integrated area =   47.926126280422835, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=1, integrated area =   47.926126280408738, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=7, integrated area =  -19.851651497355160, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=3, integrated area =   19.851651497355192, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=0, integrated area =   19.851651497358045, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=6, integrated area =  -47.926126280422835, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=5, integrated area =  -47.926126280408738, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=4, integrated area =  -19.851651497358059, step_size 0.000010, number quadratures=22500000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =    0.000000000000014

real    0m0.674s
user    0m2.592s
sys     0m0.313s
```

As you can see from both of these, the results are much closer to 0.0 than both of the past parts.

#### Displacement

Here it is for one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000000, step_size=0.000010
After Trap: my_rank=0, integrated area = 122000.000000112791895, step_size 0.000010, number quadratures=180000000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000000112791895

real    0m2.130s
user    0m1.870s
sys     0m0.032s
```

And for multiple:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500000, step_size=0.000010
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500000, step_size=0.000010
After Trap: my_rank=3, integrated area = 28979.823821396283165, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=4, integrated area = 28979.823821397127176, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=6, integrated area = 9562.920764183028950, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=5, integrated area = 20937.079235815934226, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=0, integrated area = 1520.176178604100414, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=1, integrated area = 9562.920764185360895, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=2, integrated area = 20937.079235818040615, step_size 0.000010, number quadratures=22500000
After Trap: my_rank=7, integrated area = 1520.176178603936933, step_size 0.000010, number quadratures=22500000
After Reduce: with n = 180000000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000000003812602

real    0m0.653s
user    0m2.536s
sys     0m0.210s
```

Similarly for velocity, this is closer than for the past couple parts.

