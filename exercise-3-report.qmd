---
title: "exercise-3-report"
---

## 1.

### a).

For testing the Riemann sum sequentially (using the left sum), I compiled and ran `hello_riemann.cpp` in integrating a constant function $f(x) = 10.0$ over the interval $0$ to $10.0$ using a step size of $1000000$ at a precision of $15$.

This was the result:
```bash
$ ./hello_riemann 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 10 with 1000000 steps is 100
```

For testing the Trapezoidal sum sequentially, I compiled and ran `hello_trapezoidal_constant.cpp`. I used the same values as above with the Riemann sum, and this, as you may expect, was the output:

```bash
$ ./hello_trapezoidal_constant 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 10 with 1000000 steps is 100
```

### b).

Here's the result of $f(x)=sin(x)$ using the trapezoidal method:
```bash
$ ./hello_trapezoidal 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 3.14159265358979 with 1000000 steps is 1.99999999999841
```

And here's for the Riemann sum (using the left):
```bash
$ ./hello_riemann 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 3.14159265358979 with 1000000 steps is 1.99999999999841
```

### c).

Check out `MPI_Examples/simple_function_mpi_trap.c` and see my code.

The output for it is:
```bash
$ mpiexec -n 1 ./simple_function_mpi_trap
With n = 4 trapezoids, our estimate
of the integral from 0.000000 to 100000.000000 = 1.000000000000000e+06
```

::: {.callout-caution}
The rest of my solutions will be available in `train_problems_solutions.c`

Make sure to set the definitions to the desired outputs for the program.
- For Part 2:
  - Set to PART2 + VELOCITY || DISPLACEMENT
- For Part 3:
  - Set to PART3 + VELOCITY || DISPLACEMENT
- For Part 4:
  - Set to PART4 + VELOCITY || DISPLACEMENT
- (HALF_TIME is used to check whether the derivation of velocity from acceleration actually produces the correct value by getting the peak value).
:::

## 2.

### Left Riemann - 10ms Step Size - Float Numerical Values

#### Velocity

For the velocity in the case where the step size is 10ms, make sure to set your definitions to set to PART2 + VELOCITY.

This was the output that I got:
```bash
mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000, step_size=0.010000
After LeftRiemann: my_rank=0, integrated area =       0.0350172, step_size 0.010000, number quadratures=180000
After Reduce: with n = 180000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =       0.0350172
```

As you can see, the final velocity is not zero, as we would expect. This is likely to, in large part, to the use of float values in the case of this solution.

#### Displacement

Make sure to set your definitions to PART2 + DISPLACEMENT.

```bash
$ mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000, step_size=0.010000
After LeftRiemann: my_rank=0, integrated area =  121884.0312500, step_size 0.010000, number quadratures=180000
After Reduce: with n = 180000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =  121884.0312500
```

Again, this isn't exactly the 122 km that we are expecting. Which we can again attribute, in part, to the use of float values.

## 3.

### Midpoint - 1ms Step Size - Double Numerical Values

#### Velocity

The output for the velocity using the midpoint Riemann summation at a 1ms step size and double values results in this:
```bash
mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After LeftRiemann: my_rank=0, integrated area =   -0.000000000717885, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =   -0.000000000717885
```

Well, it looks like we're just a little ways below the zero we're expecting for the stopped train. But it's definitely better from what we got in part 2 using float and the smaller step size.

I also wanted to do a half-time check to get the peak value to make sure it's correct.

So the right endpoint is 900:
```bash
$ mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=900.00000000000000, number of total steps=900000
my_rank=0, start a=0.000000, end b=900.000000, number of quadratures = 900000, step_size=0.001000
After LeftRiemann: my_rank=0, integrated area =  135.555555558113497, step_size 0.001000, number quadratures=900000
After Reduce: with n = 900000 quadratures, our estimate
of the integral from 0.000000 to 900.000000 =  135.555555558113497
```

And according to our values in the spreadsheet, this is pretty close to correct!

#### Displacement

Here's the output:
```bash
$ mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After LeftRiemann: my_rank=0, integrated area = 122000.000002825327101, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000002825327101
```

As you can see, we are certainly very close to the 122km that we are expecting. Only very slightly off. Which closer than when using floats with the left riemann sum.

## 4.

### Trapezoidal Method - 1ms Step Size - Double Numerical Values

#### Velocity

```bash
mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After LeftRiemann: my_rank=0, integrated area =   -0.000000000000007, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =   -0.000000000000007
```

``` {python}
midpoint_1ms_double_velocity = -0.000000000717885
trapezoidal_1ms_double_velocity = -0.000000000000007

proportional_difference_velocity = midpoint_1ms_double_velocity / trapezoidal_1ms_double_velocity
```

It looks like the trapezoidal method got us `{python} proportional_difference_velocity`x closer to zero than the midpoint method for the velocity!

#### Displacement

```bash
$ mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After LeftRiemann: my_rank=0, integrated area = 122000.000000003419700, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000000003419700
```

``` {python}
midpoint_1ms_double_displacement = 122000.000002825327101
trapezoidal_1ms_double_displacement = 122000.000000003419700

proportional_difference_displacement = midpoint_1ms_double_displacement / trapezoidal_1ms_double_displacement
```

It looks like the trapezoidal method got us `{python} proportional_difference_displacement`x closer to zero than the midpoint method for the displacement!
