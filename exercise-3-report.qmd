---
title: "exercise-3-report"
---

::: {.callout-important}
Change directory into `MPI_Examples/` and then `hello_integrators/` and run `make` to compile
the code into programs.
:::

## 1.

### a).

For testing the Riemann sum sequentially (using the left sum), I compiled and ran `hello_riemann.cpp` in integrating a constant function $f(x) = 10.0$ over the interval $0$ to $10.0$ using a step size of $1000000$ at a precision of $15$.

This was the result:
```bash
$ ./hello_riemann 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 10.000000000000000 with 1000000 steps is 100.000000000000014
```


For testing the Trapezoidal sum sequentially, I compiled and ran `hello_trapezoidal_constant.cpp`. I used the same values as above with the Riemann sum, and this, as you may expect, was the output:
```bash
$ ./hello_trapezoidal_constant 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 10.000000000000000 with 1000000 steps is 100.000000000000014
```

### b).

Here's the result of $f(x)=sin(x)$ using the trapezoidal method at 15 point precision:
```bash
$ ./hello_riemann 
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 3.141592653589793 with 1000000 steps is 1.999999999998408
```

And here's for the Riemann sum (using the left):
```bash
$ ./hello_trapezoidal
Will run with default: thread_count=1
The integral of f(x) from 0.0 to 3.141592653589793 with 1000000 steps is 1.999999999998408
```

### c).

Both methods produced the same results in testing the constant function and the sine function at 15 point precision. This is curious, and I'm assuming it's due to compiler optimizations because, in theory, the trapezoidal method should result in a more precise numerical value than the left Riemann sum.

Knowing this fact, I just I went ahead and picked the trapezoidal method.

Check out `MPI_Examples/simple_function_mpi_trap.c` and see my code.

The output for it is with one process:
```bash
$ time mpiexec -n 1 ./simple_function_mpi_trap
With n = 100 trapezoids, our estimate
of the integral from 0.000000 to 100000.000000 = 1.000000000000000e+06

real    0m0.288s
user    0m0.023s
sys     0m0.038s
```

The output for it with multiple processes:
```bash
$ time mpiexec -n 5 ./simple_function_mpi_trap
With n = 100 trapezoids, our estimate
of the integral from 0.000000 to 100000.000000 = 1.000000000000000e+06

real    0m0.296s
user    0m0.052s
sys     0m0.080s
```

I have 8 cores to be able to work on this, but due to the way this is set up, using 5 cores correctly divides the work across the cores to not cause remainder issues which results in incorrect calculations.

::: {.callout-note}
As you can see from the above, the MPI implementation using multiple processes doesn't really yield a speedup compared to the single process.

This could be relative to the problem. It is similarly lack luster in speed up for all the rest of the programs using MPI in this report.
:::

## 2.

::: {.callout-caution}
The rest of my solutions will be available in `train_problems_solutions.c`

- Make sure to set the definitions to the desired outputs for the program:
    - For Part 2:
      - Set to PART2 + VELOCITY || DISPLACEMENT
    - For Part 3:
      - Set to PART3 + VELOCITY || DISPLACEMENT
    - For Part 4:
      - Set to PART4 + VELOCITY || DISPLACEMENT
    - (HALF_TIME is used to check whether the derivation of velocity from acceleration actually produces the correct value by getting the peak value).

Run the program using `time mpiexec -n 1 ./train_problem_solutions` for a single process result and `time mpiexec -n 8 ./train_problem_solutions` (which seems to not have remainder issues in my testing) to get similar multi-process results.
:::

### Left Riemann - 10ms Step Size - Float Numerical Values

#### Velocity

For the velocity in the case where the step size is 10ms, make sure to set your definitions to set to PART2 + VELOCITY.

This was the output that I got when using one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000, step_size=0.010000
After LeftRiemann: my_rank=0, integrated area =       0.0350172, step_size 0.010000, number quadratures=180000
After Reduce: with n = 180000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =       0.0350172

real    0m0.288s
user    0m0.012s
sys     0m0.047s
```

As you can see, the final velocity is not zero, as we would expect. This is likely to, in large part, to the use of float values in the case of this solution.

This was the output I got when using multiple processes:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=6, integrated area =     -47.9163971, step_size 0.010000, number quadratures=22500
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=7, integrated area =     -19.8331127, step_size 0.010000, number quadratures=22500
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=0, integrated area =      19.8497849, step_size 0.010000, number quadratures=22500
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=1, integrated area =      47.9279099, step_size 0.010000, number quadratures=22500
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=2, integrated area =      47.9163933, step_size 0.010000, number quadratures=22500
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=3, integrated area =      19.8331032, step_size 0.010000, number quadratures=22500
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=4, integrated area =     -19.8681431, step_size 0.010000, number quadratures=22500
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=5, integrated area =     -47.9307785, step_size 0.010000, number quadratures=22500
After Reduce: with n = 180000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =      -0.0212383

real    0m0.300s
user    0m0.082s
sys     0m0.117s
```

The outcome is slightly different. Still very close to the 0.0 we're expecting. It is close, in terms of absolute value than using just the single worker. Which is interesting.

#### Displacement

Make sure to set your definitions to PART2 + DISPLACEMENT.

Here it is for one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 180000, step_size=0.010000
After LeftRiemann: my_rank=0, integrated area =  121884.0312500, step_size 0.010000, number quadratures=180000
After Reduce: with n = 180000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =  121884.0312500

real    0m0.289s
user    0m0.033s
sys     0m0.028s
```

Again, this isn't exactly the 122 km that we are expecting. Which we can again attribute, in part, to the use of float values.

Here it is for multiple processes:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=4, integrated area =   28977.0058594, step_size 0.010000, number quadratures=22500
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=5, integrated area =   20931.7714844, step_size 0.010000, number quadratures=22500
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=6, integrated area =    9558.1875000, step_size 0.010000, number quadratures=22500
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 22500, step_size=0.010000
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=180000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=0, integrated area =    1519.8255615, step_size 0.010000, number quadratures=22500
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 22500, step_size=0.010000
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 22500, step_size=0.010000
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 22500, step_size=0.010000
After LeftRiemann: my_rank=1, integrated area =    9566.1025391, step_size 0.010000, number quadratures=22500
After LeftRiemann: my_rank=2, integrated area =   20941.8164062, step_size 0.010000, number quadratures=22500
After LeftRiemann: my_rank=7, integrated area =    1518.7901611, step_size 0.010000, number quadratures=22500
After LeftRiemann: my_rank=3, integrated area =   28981.4023438, step_size 0.010000, number quadratures=22500
After Reduce: with n = 180000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =  121994.9062500

real    0m0.302s
user    0m0.074s
sys     0m0.122s
```

Looks like this time, the multiple process result is a little farther off than the single process result.

## 3.

### Midpoint - 1ms Step Size - Double Numerical Values

#### Velocity

Here's the output for one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After MidpointRiemann: my_rank=0, integrated area =   -0.000000000717885, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =   -0.000000000717885

real    0m0.307s
user    0m0.051s
sys     0m0.028s
```

Well, it looks like we're just a little ways below the zero we're expecting for the stopped train. But it's definitely better from what we got in part 2 using float and the smaller step size.

I also wanted to do a half-time check to get the peak value to make sure it's correct.

So the right endpoint is 900:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=900.00000000000000, number of total steps=900000
my_rank=0, start a=0.000000, end b=900.000000, number of quadratures = 900000, step_size=0.001000
After MidpointRiemann: my_rank=0, integrated area =  135.555555558113497, step_size 0.001000, number quadratures=900000
After Reduce: with n = 900000 quadratures, our estimate
of the integral from 0.000000 to 900.000000 =  135.555555558113497

real    0m0.295s
user    0m0.040s
sys     0m0.028s
```

And according to our values in the spreadsheet, this is pretty close to correct!

And here are those using more processes:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 225000, step_size=0.001000
After MidpointRiemann: my_rank=0, integrated area =   19.851651497400937, step_size 0.001000, number quadratures=225000
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 225000, step_size=0.001000
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 225000, step_size=0.001000
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 225000, step_size=0.001000
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 225000, step_size=0.001000
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 225000, step_size=0.001000
After MidpointRiemann: my_rank=5, integrated area =  -47.926126280319551, step_size 0.001000, number quadratures=225000
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 225000, step_size=0.001000
After MidpointRiemann: my_rank=6, integrated area =  -47.926126280691427, step_size 0.001000, number quadratures=225000
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 225000, step_size=0.001000
After MidpointRiemann: my_rank=7, integrated area =  -19.851651497835523, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=1, integrated area =   47.926126280373055, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=2, integrated area =   47.926126280691442, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=3, integrated area =   19.851651497835540, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=4, integrated area =  -19.851651496945660, step_size 0.001000, number quadratures=225000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =    0.000000000508809

real    0m0.304s
user    0m0.111s
sys     0m0.114s
```

```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=1, start a=112.500000, end b=225.000000, number of quadratures = 112500, step_size=0.001000
my_rank=2, start a=225.000000, end b=337.500000, number of quadratures = 112500, step_size=0.001000
my_rank=3, start a=337.500000, end b=450.000000, number of quadratures = 112500, step_size=0.001000
my_rank=4, start a=450.000000, end b=562.500000, number of quadratures = 112500, step_size=0.001000
my_rank=5, start a=562.500000, end b=675.000000, number of quadratures = 112500, step_size=0.001000
After MidpointRiemann: my_rank=5, integrated area =   21.988693642429304, step_size 0.001000, number quadratures=112500
my_rank=6, start a=675.000000, end b=787.500000, number of quadratures = 112500, step_size=0.001000
my_rank=7, start a=787.500000, end b=900.000000, number of quadratures = 112500, step_size=0.001000
my_rank=0, a=0.00000000000000, b=900.00000000000000, number of total steps=900000
my_rank=0, start a=0.000000, end b=112.500000, number of quadratures = 112500, step_size=0.001000
After MidpointRiemann: my_rank=0, integrated area =    5.159276129794845, step_size 0.001000, number quadratures=112500
After MidpointRiemann: my_rank=3, integrated area =   25.937432638075762, step_size 0.001000, number quadratures=112500
After MidpointRiemann: my_rank=1, integrated area =   14.692375367592907, step_size 0.001000, number quadratures=112500
After MidpointRiemann: my_rank=2, integrated area =   21.988693642330446, step_size 0.001000, number quadratures=112500
After MidpointRiemann: my_rank=4, integrated area =   25.937432638123873, step_size 0.001000, number quadratures=112500
After MidpointRiemann: my_rank=7, integrated area =    5.159276129915289, step_size 0.001000, number quadratures=112500
After MidpointRiemann: my_rank=6, integrated area =   14.692375367679563, step_size 0.001000, number quadratures=112500
After Reduce: with n = 900000 quadratures, our estimate
of the integral from 0.000000 to 900.000000 =  135.555555555941993

real    0m0.302s
user    0m0.089s
sys     0m0.116s
```

Which come out to right about the same values as with the single process.

#### Displacement

Here's the output from one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After MidpointRiemann: my_rank=0, integrated area = 122000.000002825327101, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000002825327101

real    0m0.306s
user    0m0.049s
sys     0m0.028s
```

As you can see, we are certainly very close to the 122km that we are expecting. Only very slightly off. Which closer than when using floats with the left riemann sum.

Here's the output from multiple processes:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 225000, step_size=0.001000
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 225000, step_size=0.001000
After MidpointRiemann: my_rank=7, integrated area = 1520.176178633141262, step_size 0.001000, number quadratures=225000
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 225000, step_size=0.001000
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 225000, step_size=0.001000
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 225000, step_size=0.001000
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 225000, step_size=0.001000
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 225000, step_size=0.001000
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 225000, step_size=0.001000
After MidpointRiemann: my_rank=6, integrated area = 9562.920764302192765, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=0, integrated area = 1520.176178604239112, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=1, integrated area = 9562.920764087259158, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=2, integrated area = 20937.079235697994591, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=3, integrated area = 28979.823821366630000, step_size 0.001000, number quadratures=225000
After MidpointRiemann: my_rank=4, integrated area = 28979.823821472131385, step_size 0.001000, number quadratures=225000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000000116473529
After MidpointRiemann: my_rank=5, integrated area = 20937.079235952871386, step_size 0.001000, number quadratures=225000

real    0m0.306s
user    0m0.117s
sys     0m0.116s
```

Even closer to what we're expecting!

## 4.

### Trapezoidal Method - 1ms Step Size - Double Numerical Values

#### Velocity

Here it is for one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After Trap: my_rank=0, integrated area =   -0.000000000000007, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =   -0.000000000000007

real    0m0.304s
user    0m0.047s
sys     0m0.029s
```

And for multiple:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 225000, step_size=0.001000
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 225000, step_size=0.001000
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 225000, step_size=0.001000
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 225000, step_size=0.001000
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 225000, step_size=0.001000
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=0, integrated area =   19.851651497335880, step_size 0.001000, number quadratures=225000
After Trap: my_rank=5, integrated area =  -47.926126280372266, step_size 0.001000, number quadratures=225000
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=1, integrated area =   47.926126280372259, step_size 0.001000, number quadratures=225000
After Trap: my_rank=2, integrated area =   47.926126280373246, step_size 0.001000, number quadratures=225000
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=6, integrated area =  -47.926126280373268, step_size 0.001000, number quadratures=225000
After Trap: my_rank=4, integrated area =  -19.851651497335872, step_size 0.001000, number quadratures=225000
After Trap: my_rank=7, integrated area =  -19.851651497336444, step_size 0.001000, number quadratures=225000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 =   -0.000000000000036
After Trap: my_rank=3, integrated area =   19.851651497336434, step_size 0.001000, number quadratures=225000

real    0m0.305s
user    0m0.112s
sys     0m0.114s
```

These come out to being closer in absolute value to 0 than with the midpoint results in part 2.

#### Displacement

Here it is for one process:
```bash
$ time mpiexec -n 1 ./train_problem_solutions
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=1800.000000, number of quadratures = 1800000, step_size=0.001000
After Trap: my_rank=0, integrated area = 122000.000000003419700, step_size 0.001000, number quadratures=1800000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000000003419700

real    0m0.305s
user    0m0.048s
sys     0m0.032s
```

And for multiple:
```bash
$ time mpiexec -n 8 ./train_problem_solutions
my_rank=2, start a=450.000000, end b=675.000000, number of quadratures = 225000, step_size=0.001000
my_rank=3, start a=675.000000, end b=900.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=3, integrated area = 28979.823821381818561, step_size 0.001000, number quadratures=225000
my_rank=4, start a=900.000000, end b=1125.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=4, integrated area = 28979.823821381713060, step_size 0.001000, number quadratures=225000
my_rank=5, start a=1125.000000, end b=1350.000000, number of quadratures = 225000, step_size=0.001000
my_rank=6, start a=1350.000000, end b=1575.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=6, integrated area = 9562.920764190459522, step_size 0.001000, number quadratures=225000
my_rank=7, start a=1575.000000, end b=1800.000000, number of quadratures = 225000, step_size=0.001000
my_rank=0, a=0.00000000000000, b=1800.00000000000000, number of total steps=1800000
my_rank=0, start a=0.000000, end b=225.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=0, integrated area = 1520.176178618088670, step_size 0.001000, number quadratures=225000
my_rank=1, start a=225.000000, end b=450.000000, number of quadratures = 225000, step_size=0.001000
After Trap: my_rank=2, integrated area = 20937.079235809658712, step_size 0.001000, number quadratures=225000
After Trap: my_rank=1, integrated area = 9562.920764190490445, step_size 0.001000, number quadratures=225000
After Trap: my_rank=7, integrated area = 1520.176178618062522, step_size 0.001000, number quadratures=225000
After Trap: my_rank=5, integrated area = 20937.079235810138925, step_size 0.001000, number quadratures=225000
After Reduce: with n = 1800000 quadratures, our estimate
of the integral from 0.000000 to 1800.000000 = 122000.000000000436557

real    0m0.305s
user    0m0.112s
sys     0m0.111s
```

Like for the velocity, both come out to be closer to 122 km than with the midpoint method in part 3.
